{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ThreatCompute Documentation \u00b6 ThreatCompute automates threat modeling, TTC estimation, and attack graph generation for Kubernetes-based systems. Core Pillars \u00b6 System model ingestion (graph-based) LLM-assisted or offline deterministic analysis Time-to-Compromise risk quantification Attack graph exploration & path extraction Quick Links \u00b6 Installation Offline Mode Threat Modeling Pipeline TTC Computation Attack Graph Generation Contributing","title":"Home"},{"location":"#threatcompute-documentation","text":"ThreatCompute automates threat modeling, TTC estimation, and attack graph generation for Kubernetes-based systems.","title":"ThreatCompute Documentation"},{"location":"#core-pillars","text":"System model ingestion (graph-based) LLM-assisted or offline deterministic analysis Time-to-Compromise risk quantification Attack graph exploration & path extraction","title":"Core Pillars"},{"location":"#quick-links","text":"Installation Offline Mode Threat Modeling Pipeline TTC Computation Attack Graph Generation Contributing","title":"Quick Links"},{"location":"installation/","text":"Installation \u00b6 git clone https://github.com/ThreatCompute/ThreatCompute.git cd ThreatCompute/ThreatCompute python -m venv .venv source .venv/bin/activate pip install --upgrade pip pip install -r requirements.txt Optional: LLM Provider Configuration \u00b6 Export your API token (DeepInfra example): export DEEPINFRA_API_TOKEN = your_token Verify \u00b6 pytest -q","title":"Installation"},{"location":"installation/#installation","text":"git clone https://github.com/ThreatCompute/ThreatCompute.git cd ThreatCompute/ThreatCompute python -m venv .venv source .venv/bin/activate pip install --upgrade pip pip install -r requirements.txt","title":"Installation"},{"location":"installation/#optional-llm-provider-configuration","text":"Export your API token (DeepInfra example): export DEEPINFRA_API_TOKEN = your_token","title":"Optional: LLM Provider Configuration"},{"location":"installation/#verify","text":"pytest -q","title":"Verify"},{"location":"api/overview/","text":"API Overview \u00b6 High-level modules: - ThreatModeling.threat_model_creator.build_threat_model \u2013 orchestrates full threat modeling pipeline. - ThreatModeling.tm_graph.tmr_to_graph \u2013 converts threat model result dict into a NetworkX DiGraph. - AttackGraphGeneration.attackgraph \u2013 builds and explores attack graphs. - TTCComputation.system_ttc / kube_ttc \u2013 TTC aggregation and per-component estimators. Offline mode surfaces through environment variable TC_OFFLINE and short-circuits LLM calls.","title":"API Overview"},{"location":"api/overview/#api-overview","text":"High-level modules: - ThreatModeling.threat_model_creator.build_threat_model \u2013 orchestrates full threat modeling pipeline. - ThreatModeling.tm_graph.tmr_to_graph \u2013 converts threat model result dict into a NetworkX DiGraph. - AttackGraphGeneration.attackgraph \u2013 builds and explores attack graphs. - TTCComputation.system_ttc / kube_ttc \u2013 TTC aggregation and per-component estimators. Offline mode surfaces through environment variable TC_OFFLINE and short-circuits LLM calls.","title":"API Overview"},{"location":"development/contributing/","text":"Contributing \u00b6 Fork & branch from main . Enable offline mode for local test speed: export TC_OFFLINE=1 . Add tests for new logic (prefer deterministic paths). Run pytest --cov and ensure threshold met. Open a Pull Request with a concise description.","title":"Contributing"},{"location":"development/contributing/#contributing","text":"Fork & branch from main . Enable offline mode for local test speed: export TC_OFFLINE=1 . Add tests for new logic (prefer deterministic paths). Run pytest --cov and ensure threshold met. Open a Pull Request with a concise description.","title":"Contributing"},{"location":"development/offline_mode/","text":"Offline Mode \u00b6 ThreatCompute supports a deterministic offline mode to enable reproducible CI and local testing without external LLM calls. Enable it by setting: export TC_OFFLINE = 1 Behavior Changes \u00b6 Component Online Offline Technique generation LLM-derived Fixed synthetic techniques Vulnerability & misconfiguration summarizers Natural language synthesis Structured counts with placeholders Asset categorization Semantic grouping via model Deterministic grouping heuristic Threat model creator tactics Prompt + parsing Single canned tactic Use Cases \u00b6 CI pipelines Air\u2011gapped environments Regression testing","title":"Offline Mode"},{"location":"development/offline_mode/#offline-mode","text":"ThreatCompute supports a deterministic offline mode to enable reproducible CI and local testing without external LLM calls. Enable it by setting: export TC_OFFLINE = 1","title":"Offline Mode"},{"location":"development/offline_mode/#behavior-changes","text":"Component Online Offline Technique generation LLM-derived Fixed synthetic techniques Vulnerability & misconfiguration summarizers Natural language synthesis Structured counts with placeholders Asset categorization Semantic grouping via model Deterministic grouping heuristic Threat model creator tactics Prompt + parsing Single canned tactic","title":"Behavior Changes"},{"location":"development/offline_mode/#use-cases","text":"CI pipelines Air\u2011gapped environments Regression testing","title":"Use Cases"},{"location":"usage/attack_graph/","text":"Attack Graph Generation \u00b6 Attack graphs combine the synthesized threat model with TTC metrics to explore feasible attack paths. Typical steps: 1. Build threat model (assets + tactics + techniques) 2. Compute TTC values for nodes 3. Feed into attack graph walker to enumerate or sample paths Key module: AttackGraphGeneration/attackgraph.py .","title":"Attack Graph Generation"},{"location":"usage/attack_graph/#attack-graph-generation","text":"Attack graphs combine the synthesized threat model with TTC metrics to explore feasible attack paths. Typical steps: 1. Build threat model (assets + tactics + techniques) 2. Compute TTC values for nodes 3. Feed into attack graph walker to enumerate or sample paths Key module: AttackGraphGeneration/attackgraph.py .","title":"Attack Graph Generation"},{"location":"usage/threat_modeling/","text":"Threat Modeling Pipeline \u00b6 The pipeline loads a system model graph (GML), analyzes assets, categorizes containers, derives tactics, and generates techniques. from ThreatModeling.threat_model_creator import build_threat_model result = build_threat_model ( \"data/system_model_MYAPP_trivy.gml\" , application = \"MYAPP\" , write_results = False ) print ( result . keys ()) # dict: assets, tactics, techniques Output Structure (Simplified) \u00b6 { \"assets\" : { \"Container\" : { \"categories\" : { \"CatA\" : { \"instances\" : [ ... ]}}}}, \"tactics\" : { \"Container\" : [{ \"tactic\" : \"Initial Access\" , \"description\" : \"...\" }]}, \"techniques\" : { \"Container\" : { \"CatA\" : { \"Execution\" : [{ \"technique\" : \"ExploitX\" , \"target\" : \"cluster\" }]}}} }","title":"Threat Modeling Pipeline"},{"location":"usage/threat_modeling/#threat-modeling-pipeline","text":"The pipeline loads a system model graph (GML), analyzes assets, categorizes containers, derives tactics, and generates techniques. from ThreatModeling.threat_model_creator import build_threat_model result = build_threat_model ( \"data/system_model_MYAPP_trivy.gml\" , application = \"MYAPP\" , write_results = False ) print ( result . keys ()) # dict: assets, tactics, techniques","title":"Threat Modeling Pipeline"},{"location":"usage/threat_modeling/#output-structure-simplified","text":"{ \"assets\" : { \"Container\" : { \"categories\" : { \"CatA\" : { \"instances\" : [ ... ]}}}}, \"tactics\" : { \"Container\" : [{ \"tactic\" : \"Initial Access\" , \"description\" : \"...\" }]}, \"techniques\" : { \"Container\" : { \"CatA\" : { \"Execution\" : [{ \"technique\" : \"ExploitX\" , \"target\" : \"cluster\" }]}}} }","title":"Output Structure (Simplified)"},{"location":"usage/ttc/","text":"Time To Compromise (TTC) \u00b6 TTC estimation assigns temporal difficulty or likelihood weightings to components and transitions. Modules: - TTCComputation/system_ttc.py - TTCComputation/kube_ttc.py Current implementation derives TTC from vulnerability / misconfiguration presence and simple aggregation heuristics.","title":"Time To Compromise (TTC)"},{"location":"usage/ttc/#time-to-compromise-ttc","text":"TTC estimation assigns temporal difficulty or likelihood weightings to components and transitions. Modules: - TTCComputation/system_ttc.py - TTCComputation/kube_ttc.py Current implementation derives TTC from vulnerability / misconfiguration presence and simple aggregation heuristics.","title":"Time To Compromise (TTC)"}]}